<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Web应用开发 第四章</title>

    <link rel="stylesheet" href="css/include.css" media="all">

    <!-- pre-libraries -->
    <script src="js/jquery-3.6.0.min.js"></script>

    <script src="js/define.js"></script>
	</head>
	<body>
		<div class="reveal pattern--random">
			<div class="slides">

        <script>
          courseName = "Web应用开发";
          chapterName = "第四章 ES6入门";
          toc = [
            {name: "ES6概述", desc: ""},
            {name: "let和const", desc: ""},
            {name: "解构赋值", desc: ""},
            {name: "字符串扩展", desc: ""},
            {name: "函数的扩展", desc: ""},
            {name: "Set和Map", desc: ""},
            {name: "Promise", desc: ""},
            {name: "async", desc: ""},
            {name: "模块", desc: ""},
          ];
        </script>

        <section class="cover" id="cover">
        </section>

				<section class="toc color--midnight" id="toc">
				</section>

				<section class="subsection color--radiant">
				</section>

				<section id="es6-basics">
					<div class="grid-wrapper">
						<div class="header">
							<div class="logo"></div>
              <h1 class="header">ES6概述</h1>
						</div>
						<div class="content full-heiht">
              <p class="fragment">ECMAScript 6.0（以下简称 ES6）是JavaScript语言的下一代标准。</p>
              <p class="fragment">已经在 2015 年 6 月正式发布了。</p>
              <p class="fragment">ES6的目标，是弥补传统JavaScript语言的缺陷，使其可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>
              <p class="fragment">ES6既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准</p>
              <p class="fragment">ES6实际上涵盖了ES2015、ES2016、ES2017 等等，</p>
              <p class="fragment">而ES2015，ES2016，ES2017则是正式名称，特指该年发布的正式版本的语言标准。</p>
            </div>
					</div>
				</section>

        <section id="es-history">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">ES的历史</h1>
            </div>
            <div class="content">
              <p class="fragment">ECMAScript 1.0是1997年发布的，</p>
              <p class="fragment">接下来的两年，连续发布了ECMAScript 2.0（1998年6月）和ECMAScript 3.0（1999年12月）。</p>
              <p class="fragment">3.0版是最成功的版本，在业界得到广泛支持，成为通行标准，奠定了JavaScript语言的基本语法，以后的版本完全继承。</p>
              <p class="fragment">Web开发者所学习JavaScript语法，其实就是在学3.0版的语法。</p>
              <p class="fragment">2000年，ECMAScript 4.0标准开始酝酿，但由于太过激进而为通过。</p>
              <p class="fragment">但是ES4中的大部分内容被ES6继承了。</p>
              <p class="fragment">2009年12月，ECMAScript 5.0版正式发布。</p>
              <p class="fragment">2011年6月，ECMAScript 5.1版发布，并且成为ISO国际标准（ISO/IEC 16262:2011）。</p>
              <p class="fragment">2013 年 3 月，ECMAScript 6草案冻结，不再添加新功能。新的功能设想将被放到ECMAScript 7。</p>
              <p class="fragment">2013 年 12 月，ECMAScript 6草案发布。然后是12个月的讨论期，听取各方反馈。</p>
              <p class="fragment">2015 年 6 月，ECMAScript 6正式通过，成为国际标准。</p>
              <p class="fragment">完全支持ES6特性的浏览器比较少，这就导致了开发过程的某些问题。</p>
              <p class="fragment">但大部分浏览器都至少完整支持ES5。</p>
              <p class="fragment">随着Node.js技术的出现，Babel等工具的使用可以使得ES6开发的程序可以被“编译”为ES5版本的代码，在任意浏览器上被运行，因此使用ES6才被大部分开发人员的接受。</p>
            </div>
          </div>
        </section> <!-- es-history -->

        <section class="subsection color--radiant">
        </section>

        <section id="let">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">let</h1>
            </div>
            <div class="content">
              <p class="fragment">除了可以使用var申明变量之外，ES6新增了let申明变量。</p>
              <p class="fragment">var申明变量时可能存在一些问题，例如变量提前申明等。</p>
              <p class="fragment">和var相比，let申明的变量有如下的特点：</p>
              <ul>
                <li class="fragment">不存在变量提申</li>
                <li class="fragment">特定块级作用域有效</li>
                <li class="fragment">暂时性死区</li>
                <li class="fragment">不允许重复申明</li>
              </ul>
            </div>
          </div>
        </section> <!-- let -->

        <section id="early-declaration">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">变量提申</h1>
            </div>
            <div class="content">
              <div class="h-parallel">
                <div style="flex: 1; margin: 0 auto;">
                  <h2>
                    <a href="demo/chapter004/declare-var.html" target="_blank" rel="noopener noreferrer">预览</a>
                  </h2>
                  <pre><code class="lang-" style="max-height: 700px;"  data-code="demo/chapter004/declare-var.html"
                    data-line-numbers="">
                  </code></pre>
                </div>
                <div style="flex: 1; margin: 0 auto;">
                  <h2>
                    <a href="demo/chapter004/declare-let.html" target="_blank" rel="noopener noreferrer">预览</a>
                  </h2>
                  <pre><code class="lang-" style="max-height: 700px;"  data-code="demo/chapter004/declare-let.html"
                    data-line-numbers="">
                  </code></pre>
                </div>
              </div>
            </div>
          </div>
        </section> <!-- early-declaration -->

        <section id="declaration-scope">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">作用域</h1>
            </div>
            <div class="content full-size">
              <div class="h-parallel full-size">
                <div style="margin: 0 auto;">
                  <h2>
                    <a href="demo/chapter004/scope-var.html" target="_blank" rel="noopener noreferrer">预览</a>
                  </h2>
                  <pre style="max-width: 550px;"><code class="lang-html" style="max-height: 700px; "  data-code="demo/chapter004/scope-var.html"
                    data-line-numbers="">
                  </code></pre>
                </div>
                <div style="margin: 0 auto;">
                  <h2>
                    <a href="demo/chapter004/scope-let.html" target="_blank" rel="noopener noreferrer">预览</a>
                  </h2>
                  <pre style="max-width: 550px;"><code class="lang-html" style="max-height: 700px; "  data-code="demo/chapter004/scope-let.html"
                    data-line-numbers="">
                  </code></pre>
                </div>
              </div>
            </div>
          </div>
        </section> <!-- declaration-scope -->

        <section id="temporary-dead-zone">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">暂时性死区</h1>
            </div>
            <div class="content">
              <div class="h-parallel full-size">
                <div style="margin: 0 auto;">
                  <h2>
                    <a href="demo/chapter004/dead-zone-var.html" target="_blank" rel="noopener noreferrer">预览</a>
                  </h2>
                  <pre style="max-width: 550px;"><code class="lang-html" style="max-height: 700px; "  data-code="demo/chapter004/dead-zone-var.html"
                    data-line-numbers="">
                  </code></pre>
                </div>
                <div style="margin: 0 auto;">
                  <h2>
                    <a href="demo/chapter004/dead-zone-let.html" target="_blank" rel="noopener noreferrer">预览</a>
                  </h2>
                  <pre style="max-width: 550px;"><code class="lang-html" style="max-height: 700px; "  data-code="demo/chapter004/dead-zone-let.html"
                    data-line-numbers="">
                  </code></pre>
                </div>
              </div>
            </div>
          </div>
        </section> <!-- temporary-dead-zone -->

        <section id="duplicate-declaration">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">重复申明</h1>
            </div>
            <div class="content">
              <div class="h-parallel full-size">
                <div style="margin: 0 auto;">
                  <h2>
                    <a href="demo/chapter004/duplicate-var.html" target="_blank" rel="noopener noreferrer">预览</a>
                  </h2>
                  <pre style="max-width: 550px;"><code class="lang-html" style="max-height: 700px; "  data-code="demo/chapter004/duplicate-var.html"
                    data-line-numbers="">
                  </code></pre>
                </div>
                <div style="margin: 0 auto;">
                  <h2>
                    <a href="demo/chapter004/duplicate-let.html" target="_blank" rel="noopener noreferrer">预览</a>
                  </h2>
                  <pre style="max-width: 550px;"><code class="lang-html" style="max-height: 700px; "  data-code="demo/chapter004/duplicate-let.html"
                    data-line-numbers="">
                  </code></pre>
                </div>
              </div>
            </div>
          </div>
        </section> <!-- duplicate-declaration -->

        <section id="const">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">const</h1>
              <h1 class="right">
                <a href="javascript:void(0)" class="edit-code">编辑</a>
                &nbsp;&nbsp;&nbsp;&nbsp;
                <a href="demo/chapter004/const.html" target="_blank" rel="noopener noreferrer">预览</a>
              </h1>
            </div>
            <div class="content">
              <p class="fragment">const声明一个只读的常量：一旦声明，常量的值就不能改变。</p>
              <p class="fragment">const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
              <p class="fragment">const的作用域与let命令相同：只在声明所在的块级作用域内有效。</p>
              <p class="fragment">const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
              <p class="fragment">const声明的常量，也与let一样不可重复声明。</p>
              <pre class="fragment"><code class="lang-html" data-code="demo/chapter004/const.html"
                data-line-numbers="">
              </code></pre>
            </div>
          </div>
        </section> <!-- const -->

        <section class="subsection color--radiant">
        </section>

        <section id="array-destructing">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">数组解构赋值</h1>
            </div>
            <div class="content">
              <p class="fragment">ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
              <p class="fragment">例如：</p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
              let [a, b, c] = [1, 2, 3];
                </script>
              </code></pre>
              <p class="fragment">
                实际上等价于：
              </p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
              let a = 1;
              let b = 2;
              let c = 3;
                </script>
              </code></pre>
              <p class="fragment">
                如果解构不成功，变量的值就等于undefined。
              </p>
            </div>
          </div>
        </section> <!-- array-destructing -->

        <section id="object-destructing">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">对象解构赋值</h1>
            </div>
            <div class="content">
              <p class="fragment">
                解构不仅可以用于数组，还可以用于对象。例如：
              </p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
              let { foo, bar } = { foo: 'aaa', bar: 'bbb' };
                </script>
              </code></pre>
              <p class="fragment">对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
              <p class="fragment">对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。有事这会很方便，例如：</p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
              const { log } = console;
              log('hello') // hello
                </script>
              </code></pre>
              <p class="fragment">
                如果变量名与属性名不一致，可以在变量中进行更新，例如：
              </p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
              let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
                </script>
              </code></pre>
            </div>
          </div>
        </section> <!-- object-destructing -->

        <section id="object-destructing-demo">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">代码：对象的解构赋值</h1>
              <h1 class="right">
                <a href="javascript:void(0)" class="edit-code">编辑</a>
                &nbsp;&nbsp;&nbsp;&nbsp;
                <a href="demo/chapter004/object-destructing.html" target="_blank" rel="noopener noreferrer">预览</a>
              </h1>
            </div>
            <div class="content">
              <pre><code class="lang-html" style="max-height: 680px;"  data-code="demo/chapter004/object-destructing.html"
                data-line-numbers="">
              </code></pre>
            </div>
          </div>
        </section> <!-- object-destructing-demo -->

        <section id="other-destructing">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">其他类型的解构赋值</h1>
            </div>
            <div class="content">
              <p class="fragment">
                字符串也可以解构赋值，例如：
              </p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
              const [a, b, c, d, e] = 'hello';
              let {length : len} = 'hello';
                </script>
              </code></pre>
              <p class="fragment">
                解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
              </p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
              let {toString: s1} = 123;
              let {toString: s2} = true;
                </script>
              </code></pre>
              <p class="fragment">
                解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。
              </p>
            </div>
          </div>
        </section> <!-- string-destructing -->

        <section id="destructing-usage">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">解构赋值的用途</h1>
            </div>
            <div class="content">
              <p class="fragment">
                交换变量的值
              </p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
              <script type="text/template">
            let x = 1;
            let y = 2;
            [x, y] = [y, x];
              </script>
            </code></pre>
              <p class="fragment">
                从函数返回多个值
              </p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
              <script type="text/template">
            function example() {
              return [1, 2, 3];
            }
            let [a, b, c] = example();
              </script>
            </code></pre>
              <p class="fragment">
                函数参数的定义
              </p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
              <script type="text/template">
            function f({x, y, z}) { ... }
            f({z: 3, y: 2, x: 1});
              </script>
            </code></pre>
              <p class="fragment">
                提取 JSON 数据
              </p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
              <script type="text/template">
            let jsonData = {
              id: 42,
              status: "OK",
              data: [867, 5309]
            };
            let { id, status, data: number } = jsonData;
              </script>
            </code></pre>
            </div>
          </div>
        </section> <!-- destructing-usage -->

        <section class="subsection color--radiant">
        </section>

        <section id="string-enhancement">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">字符串扩展</h1>
            </div>
            <div class="content">
              <p class="fragment">
                ES6中，字符串可以通过for...of进行遍历
              </p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
              for (let codePoint of 'foo') {
                console.log(codePoint)
              }
                </script>
              </code></pre>
            </div>
          </div>
        </section> <!-- string-enhancement -->

        <section id="string-template">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">模板字符串</h1>
            </div>
            <div class="content">
              <p class="fragment">ES6中新增了模版字符串（template literals）</p>
              <p class="fragment">模板字符串是增强版的字符串，用反引号（`）标识。</p>
              <p class="fragment">它可以当作普通字符串使用，或者在字符串中嵌入变量或者任何JavaScript表达式，例如：</p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
            let name = "Bob", time = "today";
            `Hello ${name}, how are you ${time}?`
                </script>
              </code></pre>
              <p class="fragment">如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p>
              <p class="fragment">如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p>
              <p class="fragment">
                也可以用来定义多行字符串，例如：
              </p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
              let lines=`In \`JavaScript\` this is
               not legal.`
                </script>
              </code></pre>
              <p class="fragment">字符串模板也可以调用函数。</p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
                  let line=`In ${func(i, j)} this is not legal.`
                </script>
              </code></pre>
              <p class="fragment">
                模板字符串常被用于快速生成HTML代码。
              </p>
            </div>
          </div>
        </section> <!-- string-template -->

        <section id="string-template-demo">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">代码：使用模板字符串</h1>
              <h1 class="right">
                <a href="javascript:void(0)" class="edit-code">编辑</a>
                &nbsp;&nbsp;&nbsp;&nbsp;
                <a href="demo/chapter004/template-literal.html" target="_blank" rel="noopener noreferrer">预览</a>
              </h1>
            </div>
            <div class="content">
              <pre><code class="lang-html" style="max-height: 680px;"  data-code="demo/chapter004/template-literal.html"
                data-line-numbers="">
              </code></pre>
            </div>
          </div>
        </section> <!-- string-template-demo -->

        <section id="string-new-method">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">新增字符串函数</h1>
            </div>
            <div class="content">
              <ul>
                <li class="fragment">includes()表示是否找到了参数字符串。</li>
                <li class="fragment">startsWith()表示参数字符串是否在原字符串的头部。</li>
                <li class="fragment">endsWith()表示参数字符串是否在原字符串的尾部。</li>
                <li class="fragment">repeat方法返回一个新字符串，表示将原字符串重复n次。</li>
                <li class="fragment">ES2017引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</li>
                <li class="fragment">ES2019对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</li>
                <li class="fragment">matchAll()方法返回一个正则表达式在当前字符串的所有匹配。</li>
                <li class="fragment">ES2021引入了replaceAll()方法，可以一次性替换所有匹配。</li>
                <li class="fragment">……</li>
              </ul>
            </div>
          </div>
        </section> <!-- string-new-method -->

        <section class="subsection color--radiant">
        </section>

        <section id="default-parameter">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">默认参数</h1>
            </div>
            <div class="content">
              <p class="fragment">
                ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。
              </p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
              function log(x, y = 'World') {
                console.log(x, y);
              }
              log('Hello') // Hello World
              log('Hello', 'China') // Hello China
              log('Hello', '') // Hello
                </script>
              </code></pre>
              <p class="fragment">参数变量是默认声明的，所以不能用let或const再次声明。</p>
              <p class="fragment">使用参数默认值时，函数不能有同名参数。</p>
              <p class="fragment">参数默认值不是传值的，而是每次都重新计算默认值表达式的值。</p>
            </div>
          </div>
        </section> <!-- default-parameter -->

        <section id="function-properties">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">函数的属性</h1>
            </div>
            <div class="content">
              <p class="fragment">默认情况下，函数的length属性是指参数的个数，但指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。</p>
              <p class="fragment">函数的name属性，返回该函数的函数名。</p>
              <ul>
                <li class="fragment">这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。</li>
                <li class="fragment">如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。</li>
              </ul>
            </div>
          </div>
        </section> <!-- function-properties -->

        <section id="arrow-function" data-fragment-order>
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">箭头函数</h1>
            </div>
            <div class="content">
              <p class="fragment"><b>箭头函数的定义</b></p>
              <div class="fragment fade-out collapse full-size" data-fragment-after="group1-last">
                <p class="fragment">
                  ES6 允许使用“箭头”（=&gt;）定义函数，例如：
                </p>
                <pre class="fragment" data-fragment-id="group1-last"><code class="lang-html" data-line-numbers="">
                  <script type="text/template">
                    var f = v => v;
                    // 等同于
                    var f = function (v) {
                      return v;
                    };
                    </script>
                </code></pre>
              </div>
              <p class="fragment"><b>箭头函数的变体</b></p>
              <div class="fragment fade-out collapse full-size" data-fragment-after="group2-last">
                <p class="fragment">如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
                <pre class="fragment"><code class="lang-html" data-line-numbers="">
                  <script type="text/template">
                    var f = () => 5;
                    // 等同于
                    var f = function () { return 5 };
                  </script>
                </code></pre>
                <p class="fragment">如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。</p>
                <pre class="fragment" data-fragment-id="group2-last"><code class="lang-html" data-line-numbers="">
                  <script type="text/template">
                    var result = (num1, num2) => { 
                      let result = num1 + num2;  
                      if(result > 10) {
                        result = num1 - num2;
                      }
                      return result;
                    }
                  </script>
                </code></pre>
              </div>
              <p class="fragment"><b>特殊情况</b></p>
              <div class="fragment fade-out collapse full-size" data-fragment-after="group3-last">
                <p class="fragment">所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p>
                <p class="fragment">如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。</p>
                <pre class="fragment" data-fragment-id="group3-last"><code class="lang-html" data-line-numbers="">
                  <script type="text/template">
                let getTempItem = id => ({ id: id, name: "Temp" });
                //等同于
                function getTempItem(id) {
                  return {id: id, name: "Temp"};
                }
                let fn = () => void doesNotReturn();
                //等同于
                function fn() {
                  doesNotReturn();
                }
                  </script>
                </code></pre>
              </div>
              <p class="fragment"><b>箭头函数可以与变量解构结合使用。</b></p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
              const full = ({ first, last }) => first + ' ' + last;
              // 等同于
              function full(person) {
                return person.first + ' ' + person.last;
              }
                </script>
              </code></pre>
            </div>
          </div>
        </section> <!-- arrow-function -->

        <section id="arrow-function-notice">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">箭头函数使用注意事项</h1>
            </div>
            <div class="content">
              <p class="fragment">
                箭头函数有几个使用注意点。
              </p>
              <ul>
                <li class="fragment">函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
                <li class="fragment">不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
                <li class="fragment">不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
                <li class="fragment">不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</li>
              </ul>
            </div>
          </div>
        </section> <!-- arrow-function-notice -->

        <section class="subsection color--radiant">
        </section>

        <section id="Set">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">Set</h1>
            </div>
            <div class="content">
              <p class="fragment">ES6 提供了新的数据结构 Set。</p>
              <p class="fragment">它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
              <p class="fragment">Set本身是一个构造函数，用来生成 Set 数据结构。</p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
              const s = new Set();
              [2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));
                </script>
              </code></pre>
              <p class="fragment">
                Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。
              </p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
              const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
              items.size // 5
                </script>
              </code></pre>
              <p class="fragment">
                Set实例的方法分为两大类：
              </p>
              <ul>
                <li class="fragment">
                  操作方法（用于操作数据）
                  <ul>
                    <li class="fragment">Set.prototype.add(value)：添加某个值，返回 Set 结构本身。</li>
                    <li class="fragment">Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
                    <li class="fragment">Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。</li>
                    <li class="fragment">Set.prototype.clear()：清除所有成员，没有返回值。</li>
                  </ul>
                </li>
                <li class="fragment">
                  遍历方法（用于遍历成员）
                  <ul>
                    <li class="fragment">Set.prototype.keys()：返回键名的遍历器</li>
                    <li class="fragment">Set.prototype.values()：返回键值的遍历器</li>
                    <li class="fragment">Set.prototype.entries()：返回键值对的遍历器</li>
                    <li class="fragment">Set.prototype.forEach()：使用回调函数遍历每个成员</li>
                  </ul>
                </li>
              </ul>
            </div>
          </div>
        </section> <!-- array-enhancement -->

        <section id="map">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">Map</h1>
            </div>
            <div class="content">
              <p class="fragment">JavaScript的对象（Object），本质上是键值对的集合（Hash 结构）。</p>
              <p class="fragment">但是对象只能用字符串当作键，这给它的使用带来了很大的限制。</p>
              <p class="fragment">ES6提供了Map数据结构</p>
              <p class="fragment">Map类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键，是一种更完善的Hash结构实现。</p>
              <p class="fragment">如果对同一个键多次赋值，后面的值将覆盖前面的值。</p>
              <p class="fragment">如果读取一个未知的键，则返回undefined。</p>
              <p class="fragment">注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。</p>
              <p class="fragment">Map 结构的实例有以下属性:</p>
              <ul>
                <li class="fragment">
                  size 属性
                </li>
              </ul>
              <p class="fragment">
                有以下操作方法：
              </p>
              <ul>
                <li class="fragment">Map.prototype.set(key, value)</li>
                <li class="fragment">Map.prototype.get(key)</li>
                <li class="fragment">Map.prototype.has(key)</li>
                <li class="fragment">Map.prototype.delete(key)</li>
                <li class="fragment">Map.prototype.clear()</li>
              </ul>
              <p class="fragment">
                有以下遍历方法：
              </p>
              <ul>
                <li class="fragment">Map.prototype.keys()：返回键名的遍历器。</li>
                <li class="fragment">Map.prototype.values()：返回键值的遍历器。</li>
                <li class="fragment">Map.prototype.entries()：返回所有成员的遍历器。</li>
                <li class="fragment">Map.prototype.forEach()：遍历 Map 的所有成员。</li>
              </ul>
            </div>
          </div>
        </section> <!-- map -->

        <section id="map-convert">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">Map和其他类型的转换</h1>
            </div>
            <div class="content">
              <p class="fragment">Map转为数组</p>
              <p class="fragment">Map 转为数组最方便的方法，就是使用扩展运算符（...）。</p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
              const myMap = new Map()
                .set(true, 7)
                .set({foo: 3}, ['abc']);
              [...myMap]
              // [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]
                </script>
              </code></pre>
              <p class="fragment">数组转为Map</p>
              <p class="fragment">将数组传入Map构造函数，就可以转为Map。</p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
              new Map([
                [true, 7],
                [{foo: 3}, ['abc']]
              ])
              // Map {
              //   true => 7,
              //   Object {foo: 3} => ['abc']
              // }
                </script>
              </code></pre>
              <p class="fragment">Map转为对象</p>
              <p class="fragment">如果所有 Map 的键都是字符串，它可以无损地转为对象。</p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
              function strMapToObj(strMap) {
                let obj = Object.create(null);
                for (let [k,v] of strMap) {
                  obj[k] = v;
                }
                return obj;
              }

              const myMap = new Map()
                .set('yes', true)
                .set('no', false);
              strMapToObj(myMap)
              // { yes: true, no: false }
                </script>
              </code></pre>
              <p class="fragment">
                如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。
              </p>
              <p class="fragment">对象转为 Map</p>
              <p class="fragment">对象转为 Map 可以通过Object.entries()。</p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
              let obj = {"a":1, "b":2};
              let map = new Map(Object.entries(obj));
                </script>
              </code></pre>
              <p class="fragment">
                此外，也可以自己实现一个转换函数。
              </p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
              function objToStrMap(obj) {
                let strMap = new Map();
                for (let k of Object.keys(obj)) {
                  strMap.set(k, obj[k]);
                }
                return strMap;
              }

              objToStrMap({yes: true, no: false})
              // Map {"yes" => true, "no" => false}
                </script>
              </code></pre>
              <p class="fragment">Map 转为 JSON</p>
              <p class="fragment">Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
              function strMapToJson(strMap) {
                return JSON.stringify(strMapToObj(strMap));
              }

              let myMap = new Map().set('yes', true).set('no', false);
              strMapToJson(myMap)
              // '{"yes":true,"no":false}'
                </script>
              </code></pre>
              <p class="fragment">
                另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。
              </p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
              function mapToArrayJson(map) {
                return JSON.stringify([...map]);
              }

              let myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);
              mapToArrayJson(myMap)
              // '[[true,7],[{"foo":3},["abc"]]]'
                </script>
              </code></pre>
              <p class="fragment">JSON 转为 Map</p>
              <p class="fragment">JSON 转为 Map，正常情况下，所有键名都是字符串。</p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
              function jsonToStrMap(jsonStr) {
                return objToStrMap(JSON.parse(jsonStr));
              }

              jsonToStrMap('{"yes": true, "no": false}')
              // Map {'yes' => true, 'no' => false}
                </script>
              </code></pre>
              <p class="fragment">
                但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。
              </p>
              <pre class="fragment"><code class="lang-html" data-line-numbers="">
                <script type="text/template">
              function jsonToMap(jsonStr) {
                return new Map(JSON.parse(jsonStr));
              }

              jsonToMap('[[true,7],[{"foo":3},["abc"]]]')
              // Map {true => 7, Object {foo: 3} => ['abc']}
                </script>
              </code></pre>
            </div>
          </div>
        </section> <!-- map-convert -->

        <section class="subsection color--radiant">
        </section>

        <section id="async-programming" data-fragment-order>
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">异步编程</h1>
            </div>
            <div class="content">
              <p class="fragment">在JavaScript的世界中，所有代码都是单线程执行的。</p>
              <p class="fragment">由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。</p>
              <p class="fragment">
                例如，我们有一个函数test，它接受一个参数，然后判断这个参数是否小于1。
              </p>
              <p class="fragment">但不幸的是，它作出这个判断需要消耗很长的时间，浏览器不可能等待这个结果。</p>
              <div class="fragment fade-out collapse full-size" data-fragment-after="group1-last">
                <pre class="fragment" data-fragment-id="group1-last"><code class="lang-cpp" data-line-numbers="">
                  <script type="text/template">
                    if(test(3)) {
                      // do something
                    } else {
                      // do otherthing
                    }
                  </script>
                </code></pre>
              </div> <!-- collapse -->
              <p class="fragment">因此，JavaScript使用了异步的概念，使用回调来处理返回结果：</p>
              <pre class="fragment"><code class="lang-cpp" data-line-numbers="">
                <script type="text/template">
                  test(3, testSuccess, testFail);
                  function testSuccess(){
                  }
                  
                  function testFail(){
                  }
                </script>
              </code></pre>
              <p class="fragment">类似的写法在JS中比比皆是，它最大的问题在于不直观，不符合人的直觉。</p>
              <p class="fragment">有没有更符合人的直觉的写法呢？</p>
            </div>
          </div>
        </section> <!-- async-programming -->

        <section id="promise-basics">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">Promise概述</h1>
            </div>
            <div class="content">
              <p class="fragment">所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p>
              <p class="fragment">从语法上说，Promise是一个对象，从它可以获取异步操作的消息。</p>
              <p class="fragment">Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。</p>
              <p class="fragment">有了Promise对象，就可以将异步操作以<b>同步操作的流程</b>表达出来，避免了层层嵌套的回调函数。</p>
              <p class="fragment">此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</p>
              <pre class="fragment"><code class="lang-cpp" data-line-numbers="">
                <script type="text/template">
                  var p = Promise(test);
                  p.then(testSuccess).catch(testFail);
                  function testSuccess(){
                  }
                  
                  function testFail(){
                  }
                </script>
              </code></pre>
              <p class="fragment">success在Promise的术语里称为resolve</p>
              <p class="fragment">而fail在Promise的术语里称为reject</p>
            </div>
          </div>
        </section> <!-- promise-basics -->

        <section id="promise-demo">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">代码：Promise示例</h1>
              <h1 class="right">
                <a href="javascript:void(0)" class="edit-code">编辑</a>
                &nbsp;&nbsp;&nbsp;&nbsp;
                <a href="demo/chapter004/promise.html" target="_blank" rel="noopener noreferrer">预览</a>
              </h1>
            </div>
            <div class="content">
              <pre><code class="lang-html" style="max-height: 680px;"  data-code="demo/chapter004/promise.html"
                data-line-numbers="">
              </code></pre>
            </div>
          </div>
        </section> <!-- promise-demo -->

        <section id="promise-characteristic">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">Promise的特点</h1>
            </div>
            <div class="content">
              <p class="fragment">
                对象的状态不受外界影响。
              </p>
              <ul>
                <li class="fragment">Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</li>
                <li class="fragment">只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li>
                <li class="fragment">这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li>
              </ul>
              <p class="fragment">
                一旦状态改变，就不会再变，任何时候都可以得到这个结果。
              </p>
              <ul>
                <li class="fragment">Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。</li>
                <li class="fragment">只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为resolved（已定型）。</li>
                <li class="fragment">如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。</li>
                <li class="fragment">这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li>
              </ul>
            </div>
          </div>
        </section> <!-- promise-characteristic -->

        <section id="promise-disadvantages">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">Promise的缺点</h1>
            </div>
            <div class="content">
              <ul>
                <li class="fragment">无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li>
                <li class="fragment">如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li>
                <li class="fragment">当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
              </ul>
            </div>
          </div>
        </section> <!-- promise-disadvantages -->

        <section class="subsection color--radiant"></section>

        <section id="why-async">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">为什么需要使用async</h1>
            </div>
            <div class="content">
              <p class="fragment">当然Promise也不是最终完美的异步解决方案，它的最大问题还是在于写法太违背人思维。</p>
              <p class="fragment">在人们长期的同步函数调用的经验下，我们更喜欢同步函数调用的方式：</p>
              <pre class="fragment"><code class="lang-js" data-code-tips data-line-numbers="">
                <script type="text/template">
                  //  RainSia::tip {{{有没有可能test是一个异步函数}}} RainSia::end
                  let result = test(2);
                  //  RainSia::tip {{{但我们不用异步函数的写法，而用同步函数的写法？}}} RainSia::end
                  if(result) {
                  } else {
                  }
                </script>
              </code></pre>
              <p class="fragment">
                答案显然是可以的，此时就该async和await关键字登场了。
              </p>
            </div> <!-- content -->
          </div> <!-- wrapper -->
        </section> <!-- why-async -->

        <section id="what-is-async">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">什么是async</h1>
            </div>
            <div class="content">
              <p class="fragment">async 和 await 关键字是最近添加到JavaScript语言里面的。</p>
              <p class="fragment">它们是ECMAScript 2017 JavaScript版的一部分。</p>
              <p class="fragment">简单来说，它们是基于promises的语法糖，使异步代码更易于编写和阅读。</p>
              <p class="fragment">通过使用它们，异步代码看起来更像是老式同步代码，因此它们非常值得学习。</p>
              <p class="fragment">
                async 是“异步”的意思，而 await 是等待的意思。所以应该很好理解 async 用于申明一个 异步的function（实际上是async function 对象），而 await 用于等待一个异步任务执行完成的的结果。
              </p>
            </div> <!-- content -->
          </div> <!-- wrapper -->
        </section> <!--  -->

        <section id="define-asyn-function">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">定义一个async函数</h1>
            </div>
            <div class="content">
              <p class="fragment">async 告诉程序这是一个异步操作。</p>
              <p class="fragment">当调用一个 async 函数时，会返回一个 Promise 对象。</p>
              <p class="fragment">当这个 async 函数返回一个值时，Promise 的 resolve 方法会负责传递这个值；</p>
              <pre class="fragment"><code class="lang-js" data-line-numbers="">
                <script type="text/template">
  async function testAsync() {
    return "hello async";
  }
  let data = testAsync().then( (data) => {
    console.log(data)
    return data
  });
  console.log(data);
                </script>
              </code></pre>
              <p class="fragment">当 async 函数抛出异常时，Promise 的 reject 方法也会传递这个异常值。</p>
            </div> <!-- content -->
          </div> <!-- wrapper -->
        </section> <!-- define-asyn-function -->

        <section id="await">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">await</h1>
            </div>
            <div class="content">
              <p class="fragment">async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</p>
              <p class="fragment">await会暂停当前async 函数执行，并且await 后面是一个表达式，即这个await 等待的是一个表达式（这个表达式返回promise 对象或者一个具体的值）：</p>
             <ul>
               <li class="fragment">假如这个表达式如果返回的是一个Promise 对象， 那么它的返回值，实际上就是 Promise 的回调函数 resolve 的参数，如果这个Promise rejected 了，await 表达式会把 Promise 的异常抛出。</li>
               <li class="fragment">假如这个表达式如果返回的是一个常量，那么会把这个常量转为Promise.resolve(xx)，同理如果没有返回值也是Promise.resolve(underfind)</li>
             </ul>
              <pre class="fragment"><code class="lang-js" data-line-numbers="">
                <script type="text/template">
async function testAwait() {
  const data = await "hello await";
  console.log(data);
  return data;
}
                </script>
              </code></pre>
            </div> <!-- content -->
          </div> <!-- wrapper -->
        </section> <!-- await -->

        <section id="await-resolve-demo">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">代码：使用await处理成功情况</h1>
              <h1 class="right">
                <a href="javascript:void(0)" class="edit-code">编辑</a>
                &nbsp;&nbsp;&nbsp;&nbsp;
                <a href="demo/chapter004/await-resolve.html" target="_blank" rel="noopener noreferrer">预览</a>
              </h1>
            </div>
            <div class="content">
              <pre><code class="lang-html" style="max-height: 680px;"  data-code="demo/chapter004/await-resolve.html"
                data-line-numbers="">
              </code></pre>
            </div>
          </div>
        </section> <!-- async-resolve-demo -->

        <section id="await-reject-demo">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">代码：Await处理失败的情况</h1>
              <h1 class="right">
                <a href="javascript:void(0)" class="edit-code">编辑</a>
                &nbsp;&nbsp;&nbsp;&nbsp;
                <a href="demo/chapter004/await-reject.html" target="_blank" rel="noopener noreferrer">预览</a>
              </h1>
            </div>
            <div class="content">
              <pre><code class="lang-html" style="max-height: 680px;"  data-code="demo/chapter004/await-reject.html"
                data-line-numbers="">
              </code></pre>
            </div>
          </div>
        </section> <!-- await-reject-demo -->

        <section class="subsection color--radiant"></section>

        <section id="what-is-module">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">什么是module</h1>
            </div>
            <div class="content">
              <p class="fragment">在使用JavaScript开发大型项目时，模块开发概念是一个必须考虑的问题。</p>
              <p class="fragment">使用模块目的就是通过命名空间对各类业务对象进行一定的封装，防止命名冲突。</p>
              <p class="fragment">在ES6之前，JavaScript本身没有模块支持，但社区创造了令人印象深刻的解决方案。两个最重要的（也是不相容的）标准是：AMD 和 CommonJS。</p>
              <p class="fragment">ES6 module 结合了CommonJS和AMD的优点：类似CommonJS，具有简洁的语法，对循环依赖的支持；类似AMD，支持异步加载和有条件的模块加载。</p>
              <p class="fragment">简单来说：ES6 module 使用 export 导出模块的内容，并使用 import 导入模块的内容。</p>
            </div> <!-- content -->
          </div> <!-- wrapper -->
        </section> <!-- what-is-module -->

        <section id="export">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">export导出</h1>
            </div>
            <div class="content">
              <p class="fragment">
                创建ES6模块时，可使用export关键字导出(对外提供)模块的内容，如函数、对象以及原始变量等等。
              </p>
              <p class="fragment">
                export 导出方案有2种：
              </p>
              <ul>
                <li class="fragment">Named exports（命名导出；每个模块可有多个）</li>
                <li class="fragment">Default exports（默认导出；每个模块只能一个）。</li>
              </ul>
            </div> <!-- content -->
          </div> <!-- wrapper -->
        </section> <!-- export -->

        <section id="named-export">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">Named exports</h1>
            </div>
            <div class="content">
              <p class="fragment">
                使用 export + 名称 的形式导出模块的内容。
              </p>
              <pre class="fragment"><code class="lang-js" data-line-numbers="">
                <script type="text/template">
// 1)声明时导出
export var myVar1 = 'a';
export let myVar2 = 'b';
export const MY_CONST = 'c';
export function myFunc() {}
 
// 2)声明后导出
var myVar3 = 'a';
export { myVar3 };
 
// 3)别名导出
var myVar4 = 'a';
export { myVar4 as myVar };
                </script>
              </code></pre>
            </div> <!-- content -->
          </div> <!-- wrapper -->
        </section> <!-- named-export -->

        <section id="default-exports">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">Default exports</h1>
            </div>
            <div class="content">
              <p class="fragment">
                使用 export default 导出模块默认的内容，每个模块只能有一个 export default。
              </p>
              <pre class="fragment"><code class="lang-js" data-line-numbers="">
                <script type="text/template">
// 1)声明时导出
export default expression;
export default function () {}
 
// 2)别名设置为default导出
export default function name1() {}
export { name1 as default };
                </script>
              </code></pre>
            </div> <!-- content -->
          </div> <!-- wrapper -->
        </section> <!-- default-exports -->

        <section id="include">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">如何使用模块文件</h1>
            </div>
            <div class="content">
              在支持ES6模块的浏览器中，引入ES6 module 的JS文件时，使用属性 type="module" 即可：
              <pre><code class="lang-js" data-line-numbers="">
                  <script type="module" src="js/math.js"></script>
                  <script type="module" src="js/app.js"></script>
              </code></pre>
            </div> <!-- content -->
          </div> <!-- wrapper -->
        </section> <!-- include -->

        <section id="import">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">import</h1>
            </div>
            <div class="content">
              <p class="fragment">使用 import 可导入创建的模块。</p>
              <p class="fragment">根据export方式的不同，import可以导入两种方式导出的内容：</p>
              <ul>
                <li class="fragment">导入默认导出</li>
                <li class="fragment">导入命名导出</li>
                <li class="fragment">仅导入模块</li>
              </ul>
            </div> <!-- content -->
          </div> <!-- wrapper -->
        </section> <!-- import -->

        <section id="import-default-export">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">导入默认导出</h1>
            </div>
            <div class="content">
              导入默认导出的模块时，需要指定模块名称
              <pre><code class="lang-js" data-line-numbers="">
                <script type="text/template">
// math.js
export default function cube(x) {
    return x * x * x;
}
 
// app.js：导入默认导出的模块时，需要指定模块名称
import cube from './math.js';
console.log(cube(3)); // => 27
                </script>
              </code></pre>
            </div> <!-- content -->
          </div> <!-- wrapper -->
        </section> <!-- import-default-export -->

        <section id="import-named-export">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">导入命名导出</h1>
            </div>
            <div class="content">
              导入模块时可使用大括号包含指定命名成员；也可以用  * as moduleName 的形式把此模块的所有命名导出作为某个对象的成员。
              <pre><code class="lang-js" data-line-numbers="">
                <script type="text/template">
// math.js
export function add(a, b) {
    return a + b;
}
 
// app.js：指定使用math模块的add命名导出
import { add } from './math.js';
console.log(add(1, 2)); // => 3
 
// 导入所有的命名导出作为math对象的成员
import * as math from './math.js';
console.log(math.add(1, 2)); // => 3
                </script>
              </code></pre>
            </div> <!-- content -->
          </div> <!-- wrapper -->
        </section> <!-- import-named-export -->

        <section id="import-module-only">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">仅导入模块</h1>
            </div>
            <div class="content">
              仅导入模块时，只会执行模块的全局函数，不会导入任何成员。
              <pre><code class="lang-js" data-line-numbers="">
                <script type="text/template">
// math.js
export function add(a, b) {
    return a + b;
}
(function() {
    console.log('hello math.js');
})();
 
// app.js
import { add } from './math.js'; // => hello math.js
                </script>
              </code></pre>
            </div> <!-- content -->
          </div> <!-- wrapper -->
        </section> <!-- import-module-only -->

        <section id="thank-you-slide" class="end color--radiant">
        </section>

      </div> <!-- slides -->
    </div> <!-- reveal -->

		<script>
      language = 'cn';

      var myConfig = {
        "math": math, 
        "asciinema": {
          rows: 24,
          cols: 81
        }
      };

      defineMyPlugins = function() {
        myPreloadPlugins = [
          /**** my plugins ****/
          RevealLoadCode, RevealFragmentOrder,
        ];
        myPlugins = [
          /**** built-in plugins ****/
          /**** third-party plugins ****/
          /**** my plugins ****/
          RevealCodeTips, RevealFragmentGroup, RevealAceEditor,
        ];
      }
    </script>
    <script src="js/common.js"></script>

	</body>
</html>
